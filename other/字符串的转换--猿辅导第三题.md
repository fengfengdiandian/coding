n：表示字符串的长度

m：转换的次数

k：一次转换的字符个数

题：已知一个长度为n的字符串，由大写的A、B或C组成，我们每次可以对k个字符进行转换，但只能转成不同于原来的字符。现在给出一个转换后的字符串，问：初始字符串经过m次转换后，转成要求字符串的方法一共有几种？
结果用1000000007求余。
（假设n、m、k都是合理的）

这题我还不清楚正确的解法，只是自己思考了一会，想到一个可能正确的解法。

看到求余，那么枚举肯定会超时，大概的思路是动态规划。

难点1: 如何去定义dp？每个位置有三种状态，用位不好表示。也想过用int去表示，即表示为三进制的数，但是也不行，只要n一大，肯定爆了。可以肯定的是，这是一个多维dp，其中必有一个维度表示当前转换的次数。

最后想到，我们可以用剩余相等的位数表示状态。

dp[i][j]：在第i次转换后，相同位数为j的方法数。

解决了难点1，这时又有了难点2，状态转移方程该怎么写？我只是知道，肯定可以用前一个状态去获得后一个状态。怎么变为代码？

这里可能需要多重for循环去获得转移后的状态
```
...
// i表示相等的位数中，几位转为不相等
for（int i = 0; i <= k; i++) {
    if (j - i 不合法) {
        continue;
    }
    // j表示不相等的位数中，几位转为相等，剩余的转为不相等
    for (int j = 0; j <= k - i; j++) {
        if (j 不合法) {
            continue;
        }
        // x表示原来的转换次数，y表示原来相等位数
        dp[x + 1][y - i + j] += C(i, y) * pow(i, 2) * C(j, n - y);
    }
}
... 
```
大概是这样的。
